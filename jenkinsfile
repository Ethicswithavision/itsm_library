
üß© EPIC: EKS Upgrade Discovery, Compatibility & Automation Foundation

Epic Description
As a platform team, we need clear visibility into Kubernetes, EKS add-ons, and third-party tooling compatibility before automating cluster upgrades, so that upgrades are safe, repeatable, and consumer-friendly.

Business Value
	‚Ä¢	Reduce upgrade risk and outages
	‚Ä¢	Reduce manual operational overhead
	‚Ä¢	Enable future automation with confidence
	‚Ä¢	Improve consumer trust in platform upgrades

‚∏ª

üü¢ STORY 1: Inventory Current Cluster Add-ons & Installation Methods

Story Title
Discover and document all EKS add-ons and third-party components per cluster

Description
As a platform engineer,
I want to identify all add-ons, agents, and tools running in EKS clusters and understand how they were installed,
So that we can assess upgrade impact and compatibility accurately.

Scope Includes
	‚Ä¢	EKS managed add-ons
	‚Ä¢	Helm-installed add-ons
	‚Ä¢	Terraform-managed resources
	‚Ä¢	DaemonSets / Operators
	‚Ä¢	Third-party agents (e.g., monitoring, security, diagnostics)

Out of Scope
	‚Ä¢	Upgrading components
	‚Ä¢	Changing installation methods

Acceptance Criteria
	‚Ä¢	A documented list of add-ons per cluster
	‚Ä¢	Each add-on includes:
	‚Ä¢	Name
	‚Ä¢	Version
	‚Ä¢	Installation method (EKS add-on / Helm / Terraform / Manual)
	‚Ä¢	Owning team or vendor (if known)
	‚Ä¢	Documentation stored in shared platform repo or Confluence

‚∏ª

üü¢ STORY 2: Create Kubernetes Version ‚Üí Add-on Compatibility Matrix (Discovery)

Story Title
Create compatibility matrix for Kubernetes versions vs add-ons

Description
As a platform engineer,
I want to understand which add-ons are required, recommended, or optional for each Kubernetes version,
So that upgrade decisions are data-driven and predictable.

Acceptance Criteria
	‚Ä¢	Compatibility matrix created for:
	‚Ä¢	Current version ‚Üí Next version (e.g., 1.31 ‚Üí 1.32)
	‚Ä¢	Each add-on categorized as:
	‚Ä¢	Required (must upgrade)
	‚Ä¢	Recommended (best practice)
	‚Ä¢	Optional
	‚Ä¢	Source of compatibility noted (vendor docs, EKS docs, observed behavior)
	‚Ä¢	Matrix reviewed with at least one senior engineer

‚∏ª

üü¢ STORY 3: Research Kubernetes & EKS Upgrade Change Impacts

Story Title
Analyze Kubernetes and EKS version upgrade changes and risks

Description
As a platform engineer,
I want to review upstream Kubernetes and EKS-specific changes for target versions,
So that we understand API changes, behavior changes, and potential risks.

Acceptance Criteria
	‚Ä¢	Summary document covering:
	‚Ä¢	Kubernetes upstream changes
	‚Ä¢	Deprecated / removed APIs
	‚Ä¢	EKS-specific behaviors
	‚Ä¢	Clear notes on:
	‚Ä¢	Breaking changes
	‚Ä¢	Non-breaking but risky changes
	‚Ä¢	Document linked to upgrade playbook

‚∏ª

üü¢ STORY 4: Define Pre-Upgrade Cluster Health & Diagnostic Checks

Story Title
Define mandatory pre-upgrade health and diagnostic checks

Description
As a platform engineer,
I want a standard set of health checks before upgrades,
So that upgrades are only performed on healthy clusters.

Acceptance Criteria
	‚Ä¢	List of required checks documented, including:
	‚Ä¢	Cluster health
	‚Ä¢	Node health
	‚Ä¢	Add-on health
	‚Ä¢	Diagnostics status
	‚Ä¢	Clear pass/fail criteria defined
	‚Ä¢	Decision rule documented:
	‚Ä¢	‚ÄúFail ‚Üí upgrade blocked‚Äù
	‚Ä¢	Identified candidates for future automation

‚∏ª

üü¢ STORY 5: Document Upgrade Order of Operations (Control Plane ‚Üí Add-ons)

Story Title
Document standard EKS upgrade execution order

Description
As a platform engineer,
I want a clearly defined order of upgrade steps,
So that all upgrades follow a consistent and safe process.

Acceptance Criteria
	‚Ä¢	Documented upgrade order including:
	1.	Pre-checks
	2.	Required add-on upgrades
	3.	Control plane upgrade
	4.	Node upgrades
	5.	Post-upgrade validation
	‚Ä¢	Notes on which steps are version-agnostic
	‚Ä¢	Reviewed and validated against past upgrade executions

‚∏ª

üü¢ STORY 6: Identify Manual Steps Suitable for Automation

Story Title
Identify manual upgrade steps that can be automated

Description
As a platform engineer,
I want to identify repetitive manual tasks during upgrades,
So that we can prioritize automation effectively.

Acceptance Criteria
	‚Ä¢	List of manual steps observed during real upgrades
	‚Ä¢	Each step tagged as:
	‚Ä¢	Automatable now
	‚Ä¢	Automatable later
	‚Ä¢	Must remain manual
	‚Ä¢	Reason documented for each classification
	‚Ä¢	Inputs and outputs defined per step

‚∏ª

üü¢ STORY 7: Define MVP Automation Scope for Upgrade Workflow

Story Title
Define MVP scope for EKS upgrade automation

Description
As a platform engineer,
I want to define a realistic first automation milestone,
So that automation is incremental and safe.

Acceptance Criteria
	‚Ä¢	MVP automation scope documented
	‚Ä¢	Explicit exclusions listed
	‚Ä¢	Dependencies identified (APIs, permissions, data sources)
	‚Ä¢	Alignment confirmed with platform leads

‚∏ª

üü¢ STORY 8: Shadow Live Upgrade Activities and Capture Findings

Story Title
Shadow live EKS upgrade and add-on installation activities

Description
As a platform engineer,
I want to shadow real upgrade executions,
So that documentation reflects actual behavior, not assumptions.

Acceptance Criteria
	‚Ä¢	At least one live upgrade or add-on installation shadowed
	‚Ä¢	Observations documented:
	‚Ä¢	Deviations from playbook
	‚Ä¢	Manual interventions
	‚Ä¢	Hidden dependencies
	‚Ä¢	Findings fed back into discovery documentation

‚∏ª

üü¢ STORY 9: Consumer-Facing Upgrade Experience (Future Design)

Story Title
Design future consumer upgrade experience and validation flow

Description
As a platform team,
We want to envision how consumers will safely request upgrades,
So that the platform reduces operational burden and errors.

Acceptance Criteria
	‚Ä¢	High-level flow documented:
	‚Ä¢	Version selection
	‚Ä¢	Compatibility validation
	‚Ä¢	Required actions surfaced
	‚Ä¢	No implementation required
	‚Ä¢	Design reviewed with stakeholders









re are the meeting minutes (cleaned up + structured) from what you shared. I‚Äôm keeping the language close to what was discussed, but organized so you can send it to Matt / the team.

‚∏ª

Meeting Minutes ‚Äî ECR Pipeline + Nova Integration Alignment

1) Purpose of the discussion
	‚Ä¢	The team wants internal alignment first (ECR team only) before bringing in others (Felix / Matt / external teams).
	‚Ä¢	Key outcome desired: define ‚Äúscope of success‚Äù for the ECR pipeline + Nova work, and ensure the team is on the same technical page.

‚∏ª

2) Roles / ownership clarity
	‚Ä¢	ECR team = owners of the ECR pipeline/product.
	‚Ä¢	Felix = brings expertise (especially around architecture/service-catalog type infrastructure), but is not the Jenkins agent owner.
	‚Ä¢	Jenkins agent / controller ownership is separate (controller is managed by another team; ECR team consumes it).

‚∏ª

3) High-level pipeline model (agreed mental model)

10,000 ft view of what a consumer pipeline is expected to do:
	1.	Developer commits code (source of truth = Git)
	2.	Pipeline runs build steps (compile/package: jar/war/wheel/npm build/etc.)
	3.	Build output artifacts are stored (example given: Artifactory) for traceability
	4.	Docker image build happens (Dockerfile + artifact)
	5.	Image pushed to ECR
	6.	Optional: signing / scanning / compliance steps
	7.	Optional: deployment step (EKS/ArgoCD/etc.)

Notes:
	‚Ä¢	Many security checks exist in real pipelines (Snyk/SAST/container scans/linters/etc.) but those can be treated as ‚Äústeps in the workflow.‚Äù
	‚Ä¢	Critical operational requirement: when failures happen, teams need traceability back to commit + artifact + image.

‚∏ª

4) Nova‚Äôs role in the solution

Nova is not the trigger source-of-truth.
	‚Ä¢	Source-of-truth trigger remains: Git webhook.
	‚Ä¢	Nova should serve as:
	‚Ä¢	A UI to view pipeline runs/stages/progress
	‚Ä¢	A place to re-run a pipeline (either from start, or from a step if supported)
	‚Ä¢	A place to provide ‚Äúone-stop‚Äù experience where needed (ex: provisioning repos/infrastructure via service catalog)

‚∏ª

5) Key decision: GitOps over S3 upload

Decision: Do not use ‚Äúupload zip to S3 and build from S3‚Äù pattern as the primary solution.

Reasons captured in discussion:
	‚Ä¢	S3 is not a source of truth in the same way Git is.
	‚Ä¢	Git provides:
	‚Ä¢	commit history, traceability, accountability
	‚Ä¢	easy investigation during incidents (‚Äúshow me the commit that produced this‚Äù)
	‚Ä¢	Uploading zip breaks clean traceability and complicates governance.

Direction going forward: enforce a Git-based model (‚ÄúGitOps style‚Äù), regardless of whether the user is testing or building production.

‚∏ª

6) Credential / secret handling (Vault integration)

Agreed principles:
	‚Ä¢	Secrets must live in Vault (not hardcoded in Jenkins jobs/pipelines).
	‚Ä¢	Consumers must not give broad ‚Äúgod tokens‚Äù that access everything.
	‚Ä¢	Prefer a model where:
	‚Ä¢	consumer provides a scoped token (HTTP access token or SSH key) for repo access
	‚Ä¢	token is stored in Vault under an agreed path
	‚Ä¢	pipeline fetches the token from Vault at runtime

Open design points discussed:
	‚Ä¢	Token per repo vs token per org/team:
	‚Ä¢	Best practice direction mentioned: avoid token-per-repo explosion if possible (ops nightmare)
	‚Ä¢	Nova may provide the UI to onboard/store tokens into Vault (one-time onboarding experience).

‚∏ª

7) Scope boundaries (important alignment)

The team separated concerns clearly:

What is in scope for ECR pipeline
	‚Ä¢	Build Docker image
	‚Ä¢	Basic image checks (lint / container scan / minimal validation)
	‚Ä¢	Push image to ECR
	‚Ä¢	Provide Nova integration for visibility/triggering

What is out of scope (owned by other build frameworks)
	‚Ä¢	Full application build frameworks (running all app-level steps)
	‚Ä¢	Managing all app-specific SAST/SCA rules (beyond minimal container/image controls)
	‚Ä¢	Solving every consumer build style (Java/Node/Python) end-to-end inside ECR pipeline

The expected assumption is:
	‚Ä¢	The consumer (or their app build pipeline) already produced the artifact / content needed for the Docker build stage.

‚∏ª

8) Authorization and ‚Äúwho can push where‚Äù problem (security gap)

A major concern raised:
	‚Ä¢	If pipeline uses a powerful shared identity, what prevents pushing/overwriting into other teams‚Äô ECR repos?
	‚Ä¢	ECR doesn‚Äôt have a ‚ÄúKoi organization‚Äù concept; so we need a mapping/authorization layer.

Ideas mentioned:
	‚Ä¢	Use Nova backend authorization similar to existing patterns:
	‚Ä¢	Map AD groups / ownership to allowed repos/accounts
	‚Ä¢	Backend API checks user‚Äôs group membership before allowing actions
	‚Ä¢	Control via IAM:
	‚Ä¢	role assumption into workload accounts
	‚Ä¢	repo policies to restrict access
	‚Ä¢	naming convention constraints (ex: eks/<team>/<repo>), but naming alone doesn‚Äôt fully prevent misuse unless enforced.

Decision status:
	‚Ä¢	Not fully solved; acknowledged as a must-fix before inviting consumers.
	‚Ä¢	Past experience: security hardening took major time and is expected again.

‚∏ª

9) Jenkins vs GitHub Actions timeline consideration
	‚Ä¢	Team discussed: don‚Äôt overbuild Jenkins-only solutions if GitHub Actions migration is soon.
	‚Ä¢	Current belief: GitHub Actions migration could be 1‚Äì2 years, not months ‚Üí building Jenkins-based approach is likely worth it.
	‚Ä¢	Still noted as a risk: avoid building something that gets thrown away quickly.

‚∏ª

10) Service Catalog / Felix scope question

Felix is expected to help with:
	‚Ä¢	Infrastructure requirements / service catalog integration
	‚Ä¢	Possibly: ‚Äúcreate repo if not exists‚Äù workflow from Nova
	‚Ä¢	Helping define how Nova connects to service catalog provisioning

Important note:
	‚Ä¢	Guardrails (SCPs/controls) should not be enforced until the solution is usable, otherwise teams get blocked with no path forward.

‚∏ª

11) Near-term plan / next steps
	1.	Proceed with GitOps approach (no S3 upload model).
	2.	Define onboarding flow:
	‚Ä¢	consumer provides repo token once
	‚Ä¢	stored in Vault
	‚Ä¢	used by pipeline at runtime
	3.	Nova integration work:
	‚Ä¢	trigger / view pipeline runs via Jenkins API (similar to EKS patching access pattern)
	‚Ä¢	show stages and link to logs
	4.	Security model:
	‚Ä¢	minimum viable security for pilot: 1 consumer / 1 AD group / 1 workload account
	‚Ä¢	later scale to broader mapping
	5.	Set up follow-up meeting with Matt + Felix + internal team:
	‚Ä¢	objective: confirm Felix scope and Nova integration expectations
	‚Ä¢	reject ideas that fundamentally replace the agreed GitOps plan unless it truly improves it

‚∏ª

12) Action items
	‚Ä¢	Sandeep: share these minutes + align with team on next sprint tasks (Nova trigger/API integration, pipeline integration plan)
	‚Ä¢	Team (Pradeep/Reza/etc.): continue pipeline work under GitOps assumptions; identify what data/stages Nova must display
	‚Ä¢	Lead/Shaman: connect with Matt and schedule Felix discussion; confirm Q2 expectation for consumer pilot/readiness
	‚Ä¢	Everyone: document the agreed approach (diagrams + responsibilities + interfaces)

‚∏ª

13) Open questions (to take into next call)
	‚Ä¢	What is the minimal ‚ÄúFelix success score‚Äù (deliverables) for this quarter?
	‚Ä¢	service catalog integration?
	‚Ä¢	repo creation workflow?
	‚Ä¢	Nova component template support?
	‚Ä¢	What is the minimal security model required to pilot safely?
	‚Ä¢	Exact Vault integration approach:
	‚Ä¢	Who writes secrets into Vault (Nova vs consumer)?
	‚Ä¢	What is the secret path convention?
	‚Ä¢	Jenkins pipeline re-run behavior:
	‚Ä¢	restart from stage vs rerun from start?














Minutes ‚Äì ECR Image Build + Nova Integration Discussion

Date: (add date)
Attendees: Sandeep, Pradeep, Felix, Reza (mentioned), Shraman/Matt (referenced), AOS Utilities (Greg/Rob mentioned)

1) Context / Goal
	‚Ä¢	Team
 is aligning on how consumers will build and publish container images to ECR and how much of that experience should live in Nova/Backstage.
	‚Ä¢	Two tracks are in flight:
	1.	ECR repository creation (Service Catalog/Terraform module work ‚Äì Felix)
	2.	Image build pipeline (Jenkins-based pipeline ‚Äì Felix pipeline being leveraged; Reza/Pradeep involved)

2) Current Consumer Experience Observed (OpenShift reference)
	‚Ä¢	OpenShift currently supports a commit/tag-based build experience:
	‚Ä¢	Commit triggers build (non-release build)
	‚Ä¢	Tag triggers release build (image is tagged/versioned)
	‚Ä¢	This is considered a good developer experience and preferred over ‚Äúmanual upload‚Äù approaches.

3) Key Discussion Points

A. Where should the build be triggered from?
	‚Ä¢	Strong preference stated: commit/tag in Git should trigger builds (Git as source of truth).
	‚Ä¢	Concern raised: ‚ÄúNova-triggered builds with manual parameters‚Äù can feel like click-ops and increases platform glue/API work.
	‚Ä¢	Agreement that consumers generally should not need Jenkins console access; Nova can provide visibility.

B. Repo access / credentials challenge
	‚Ä¢	Main blocker: Jenkins needs a secure way to read consumer Bitbucket repos.
	‚Ä¢	Options discussed:
	‚Ä¢	Tactical approach: AOS Utilities provides a functional read-only Bitbucket user/key with access to relevant repos/projects; store credential in Vault; Jenkins uses it for checkout.
	‚Ä¢	Strategic approach: OIDC/JWT-based trust between Jenkins and Vault + per-team secrets/policies (least privilege). Not ready immediately.

C. Rejecting ‚Äúupload to S3‚Äù as source workflow
	‚Ä¢	Proposal was mentioned earlier (upload tar/zip to S3 then build).
	‚Ä¢	Strong objection: This breaks Git as source of truth, creates another ‚Äúbook of record‚Äù, and complicates audit/provenance.
	‚Ä¢	Conclusion: S3 upload path should not be the primary approach.

D. Image versioning / rebuild behavior
	‚Ä¢	Release builds based on tagging was supported.
	‚Ä¢	Rebuild same version/tag came up (e.g., fix labels/scanning):
	‚Ä¢	Need clear policy whether tags are immutable or allow re-tag/rebuild (digest tracking recommended).
	‚Ä¢	Consumers currently sometimes delete tag and rebuild; need guidance.

4) Nova/Backstage Scope Discussion
	‚Ä¢	Minimum Nova requirement (near-term / demo): enable a consumer-facing experience without requiring Jenkins access:
	‚Ä¢	View image repository, tags, build history (visibility)
	‚Ä¢	Provide documentation and clear onboarding steps
	‚Ä¢	Desired end-state (later):
	‚Ä¢	One place in Nova for:
	1.	Create ECR repo (Service Catalog integration)
	2.	Build/push images (either Git-native or Nova-triggered path‚ÄîTBD)

5) Timeline / Expectations (as stated in discussion)
	‚Ä¢	Near term focus: deliver a working pipeline (even if consumer UX is minimal at first).
	‚Ä¢	Q1/Q2 sequencing implied:
	‚Ä¢	Q1: Discovery + alignment + working pipeline foundation
	‚Ä¢	Later: refine Nova UX and standardize onboarding

6) Decisions / Agreements (Provisional)
	‚Ä¢	Preferred model: Git-based commit/tag triggers; avoid S3 upload workflow.
	‚Ä¢	Repo access will be pursued via AOS Utilities (functional read-only access) as the tactical unblocker.
	‚Ä¢	Vault is the preferred storage mechanism for credentials (align with enterprise standard).

7) Risks / Open Questions
	‚Ä¢	Who owns and operates the functional Bitbucket credential long-term? (rotation, audit, approvals)
	‚Ä¢	Should tag overwrites be allowed? If yes, what guardrails?
	‚Ä¢	Do we support both:
	‚Ä¢	Git-native webhook model (default)
	‚Ä¢	Nova-triggered build model (exception/future)
	‚Ä¢	What is the minimal Nova UI/UX required for consumer testing vs internal demo only?

8) Action Items
	1.	Sandeep to contact Greg / Rob (AOS Utilities) to confirm feasibility of functional read-only Bitbucket access for required repos/projects.
	2.	Sandeep to share summary/minutes with Shraman, Dan, Matt and align on which model is default for Phase 1.
	3.	Pradeep + Reza to outline ‚Äúconsumer steps‚Äù (onboarding checklist) and required pipeline parameters (repo, branch, dockerfile path, ECR repo, tag).
	4.	Felix to provide current pipeline details and confirm what parameters/API triggers are supported.
	5.	Group to decide Phase 1 scope for Nova:
	‚Ä¢	‚ÄúVisibility-only + create ECR repo‚Äù vs ‚Äúalso trigger build‚Äù
